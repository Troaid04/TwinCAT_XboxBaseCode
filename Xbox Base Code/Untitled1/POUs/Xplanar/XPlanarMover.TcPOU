<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="XPlanarMover" Id="{3939b667-1d94-4118-9d46-041468b4f25e}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK XPlanarMover
VAR_INPUT
	
			MotionParameters			:		Motion_Parameters; // Min-max Motion parameters

			MoverType					: 		STRING(7); //Input what mover is being controlled

END_VAR
VAR_OUTPUT
	
			Xplanar_Mover 				: 		MC_PlanarMover; // Xplanr Mover fb
			moverState					:		MC_Planar_State; // State of mover
			
			TypeWidth					: 		LREAL; //Mover Width  		
			TypeLength					:		LREAL; //Mover Length
END_VAR
VAR
	
			stExtOptions				:		ARRAY [1..2]  OF ST_ExternalSetpointGenerationOptions; // External Setpoint options
			cmdFB 						:		ARRAY [1..2]  OF MC_PlanarFeedBack ; //Mover Feedback 
			XpPosition					:		MoverVector; // Commanded mover pos
			MoverPos					:		MoverVector; // Act pos of mover
			ZeroVector 					:		MoverVector; // Zero feed for External Pos

			
			
			EnvironmentParameters		:		Environment_Parameters; // Enviroment parameters like table boundry, fricition coeffecent 
			typeAMP4220					: 		AMP4220; // Mover 4220 decleration	
			
		
			//Init Vars
			Run 						:		BOOL; // Run init case	
			DONE						: 		BOOL; // Done running init
			nCase 						: 		SINT := 1; // Case of init
			init_counter				:		INT; // How many times we can try to recover

			
 			//X Y vars
			SumnedForce_X				: 		LREAL; // Calculation of applied force on X
			SumnedForce_Y 				: 		LREAL; // Calculation of applied force on Y
			Mover_acceleration			: 		MoverVector; // Commanded Mover Acc
			friction_force				: 		MoverVector; // Fricition against mover
			SumnedVelocity				: 		MoverVector; // Commanded Velocity after intergation 
			
			
			//Recover Vars
			nRecover					:		SINT := 1; // Case of Recover
			bRecover					: 		BOOL; // Recover mover 
			
			
			//Height Vars
			Height 						: 		LREAL := 2; // Varible in which height is passed
			Left_OSR					: 		R_TRIG; // OSR to make sure a left bumper click is counted a one
			Right_OSR					: 		R_TRIG; // OSR to make sure a right bumper click is counted a one
			Left_Bumer_TON				:		TON; // Timer for incremental lowering 
			Right_Bumper_TON			:		TON; // Timer for incremental rising 
			Smoothing_Left_TON			:		TON; // Timer for smoothing on lowering 
			Smoothing_Right_TON			:		TON; // Timer for smoothing on rising 

			
			
			
			
END_VAR
VAR_IN_OUT
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[Cyclic(); 



	Xplanar_Mover.SetExternalSetpoint( XpPosition, ZeroVector, ZeroVector);

]]></ST>
    </Implementation>
    <Action Name="Cyclic" Id="{82484dc3-e441-4c06-856d-d2ed15a41028}">
      <Implementation>
        <ST><![CDATA[//Mover 1 updates
Xplanar_Mover.Update(); 
cmdFB[1].Update();
moverState := Xplanar_Mover.MCTOPLC.STD.State;
MoverPos := Xplanar_Mover.MCTOPLC.ACT.ActPos;
typeAMP4220(); 



IF MoverType = 'AMP4220' THEN
	TypeWidth := typeAMP4220.MoverTypeWidth;
	TypeLength := typeAMP4220.MoverTypeLength;
END_IF

//Condition for init of mover to run
]]></ST>
      </Implementation>
    </Action>
    <Method Name="Height" Id="{a081a7d9-e07b-49a5-bb9d-587c5faff0c3}">
      <Declaration><![CDATA[METHOD Height
VAR_INPUT
	
LBumper 					: BOOL; 
RBumper 					: BOOL; 

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Done THEN 
	
	// Hold down for automatic raise and lowering
	Left_Bumer_TON(IN := LBumper, PT := T#0.25S); 
	Right_Bumper_TON(IN := RBumper, PT := T#0.25S);
	Smoothing_Left_TON(PT := T#0.1S);
	Smoothing_Right_TON(PT := T#0.1S);

	// If timer then activate other then repeat
	IF Left_Bumer_TON.Q THEN
		Smoothing_Left_TON.IN := TRUE AND NOT Smoothing_Left_TON.Q;
	ELSE
		Smoothing_Left_TON.IN := FALSE;		
	END_IF
	
	// If timer then activate other then repeat
	IF Right_Bumper_TON.Q THEN
		Smoothing_Right_TON.IN := TRUE AND NOT Smoothing_Right_TON.Q;
	ELSE
		Smoothing_Right_TON.IN := FALSE;
	END_IF
	
	
	// OSR to make sure only one is seen per click if intention
	Left_OSR(CLK:= LBumper, Q=> ); // OSR for left bumper 
	Right_OSR(CLK:= RBumper, Q=> ); // OSR for right bumper 
	
	// Raise and lowering of mover + implemntation of limits on height
	// Can go negative for holding force 
	IF (Left_OSR.Q OR Smoothing_Left_TON.Q) AND Height >= -0.35 THEN 
		Height :=  Height - 0.15; // Decrease Height 
	ELSIF (Right_OSR.Q OR Smoothing_Right_TON.Q) AND Height < 5.0 THEN
		Height := Height + 0.15; // Increase Height 
	ELSE
		Height := Height; // No change 
	END_IF

	XPPosition.z		:= Height; // Passing in height to Exterenal setpoint generator
	
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{def29215-c1db-47bd-a987-c8cae1603651}">
      <Declaration><![CDATA[METHOD Init
VAR_INPUT
	
	bStart 						: 		BOOL; // Start button on controller

END_VAR
VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF bStart THEN
	Run := TRUE;
END_IF

IF (Run OR bRecover) AND NOT (init_counter = 3) THEN
	CASE nCase OF
	1: 
	
		Done := FALSE;
		Xplanar_Mover.Reset(cmdFB[1]);
		nCase := 2;
	
	2:
	
		IF cmdFB[1].Done THEN
			nCase := 3; 
		END_IF
		
	3:
	
		Xplanar_Mover.Enable(cmdFB[1]);
		nCase := 4;
		
	4:
	
		IF cmdFB[1].Done THEN
			nCase := 5;
		END_IF
		
	5:
	
		stExtOptions[1].mode := MC_EXTERNAL_SET_POSITION_MODE.Absolute; // Setting up external Setpoint generator
		nCase := 6; 
	
	6:
	
		IF  MoverState = 5 OR  MoverState = 1 THEN 
			nCase := 1;		
		ELSE 		
			nCase := 7;
		END_IF 
	
	7:
		IF MoverState = 3 THEN 
			nCase := 8;
		END_IF
	
	
	8:
		//Update Positions to real world value before initization of External Setpoint
		IF cmdFB[1].Done  AND NOT cmdFB[1].Busy AND NOT cmdFB[2].Busy  THEN
			XpPosition.y := MoverPos.y; 
			XpPosition.x := MoverPos.x; 
			XpPosition.z := MoverPos.z;
			XpPosition.c := MoverPos.c;
			nCase := 9;
		END_IF
	
	
	9:
	
		//Start External Setpoint Generatior
		Xplanar_Mover.StartExternalSetpointGeneration(cmdFB[1], stExtOptions[1]); 
		nCase := 10; 
	10:
	
		nCase := 11;
		
	11:
	
	// If errored be able to reset 
	IF MoverState = 5 OR  MoverState = 1 THEN
		init_Counter := init_Counter + 1; 
		nCase := 1; 
	ELSE
		Done := TRUE; // Set true to allow for movement 
		Run := FALSE; // Dont call init over again
		bRecover := FALSE; // Dont recover if enabled and ready
		init_counter := 0; // Reset init try's counter
	END_IF
		
	END_CASE
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Recover" Id="{e6a63d81-483f-4a71-99d2-c7f5840dab5a}">
      <Declaration><![CDATA[METHOD Recover
VAR_INPUT
	
			bBack 							: BOOL ; 

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE nRecover OF 
	1:
		IF Done OR (init_Counter = 3) THEN
			nRecover := nRecover + 1;
		END_IF
	
	2:
	
		IF  MoverState = 5 OR  MoverState = 1 THEN
			Done := FALSE; // Done bit false so no movement can be called	
			nRecover := nRecover + 1; 
		END_IF
		
	3:
		//Mapped as reset of mover
		IF bBack = TRUE THEN
			nRecover := nRecover + 1; 
		END_IF
		
	4:
		
		nCase := 1; // places in case one of init 	
		bRecover := TRUE; // Calls init of mover
		init_counter := 0; // Resets mover init count 

		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Rotation" Id="{93c77cf9-6e7f-471c-a695-31105a4ae36b}">
      <Declaration><![CDATA[METHOD Rotation : BOOL
VAR_INPUT
	
LTrigger 				: INT ; 
RTrigger 				: INT ; 

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF Done AND (NOT MoverState = 5 OR  MoverState = 1) THEN 
	
//END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Tilt" Id="{c7f673dd-bde8-4bb0-a48c-edd491df8f0b}">
      <Declaration><![CDATA[METHOD Tilt
VAR_INPUT
	
rStick_X 				: LREAL; // Right stick X axis - tilt on B
rStick_Y				: LREAL; // Right stick Y axis - tilit on A
bButton_B 				: BOOL;  // Button B on controller - anti slosh

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Done THEN 
	
	//A tilt 
	XpPosition.a	:= EnvironmentParameters.tiltscailing * rStick_Y;
	
	//B tilt 	
	XPPosition.b   	:= EnvironmentParameters.tiltscailing * rStick_X; 


END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="XYMovement" Id="{baec03b5-3e08-481e-807f-3454b9c413ba}">
      <Declaration><![CDATA[METHOD XYMovement
VAR_INPUT
	
lStick_X 				: LREAL; // Left stick X axis - X movement of mover
lStick_Y				: LREAL; // LEft stick Y axis - Y movement of mover

bButton_A 				: BOOL;  // Button A on controller - homing to rotation position
bButton_X 				: BOOL;  // Button X on controller - locking into X movement 
bButton_Y 				: BOOL;	 // Button Y on controller - locking into Y movement
 
maxXtravel              : LREAL; // Max X travel on table
minXTravel              : LREAL; // Min X travel on table
maxYTravel              : LREAL; // Max Y travel on table
minYTravel				: LREAL; // Min Y travel on table

END_VAR
VAR
END_VAR
VAR_IN_OUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Done THEN 

	// Read the analog stick inputs (x and y) and scale them to control acceleration
    // Input values are assumed to be in the range [-200, 200] for both x and y axes
    // Scale them to the range [-max_acceleration, max_acceleration] for acceleration
	Mover_acceleration.x := lStick_X * MotionParameters.maxAcceleration / 200.0;
   	Mover_acceleration.y := lStick_Y * MotionParameters.maxAcceleration / 200.0;


    // If there is no acceleration command, apply friction to reduce velocity
	friction_force.x := -1 * EnvironmentParameters.Friction_coefficient * SumnedVelocity.x;
	friction_force.y := -1 * EnvironmentParameters.Friction_coefficient * SumnedVelocity.y;

	
	// Reduce acceleration based on the friction force
	SumnedForce_X := Mover_acceleration.x + friction_force.x;
	SumnedForce_Y := Mover_acceleration.y + friction_force.y;

	// Update the object's velocity based on the acceleration (INTEGRATING)
	SumnedVelocity.x := LIMIT(MotionParameters.minVelocity, SumnedVelocity.x, MotionParameters.maxVelocity) + (SumnedForce_X * MotionParameters.deltaT);
	SumnedVelocity.y := LIMIT(MotionParameters.minVelocity, SumnedVelocity.y, MotionParameters.maxVelocity) + (SumnedForce_Y * MotionParameters.deltaT);

	
	// Update the object's position based on the velocity(INTEGRATING)	
	XpPosition.x		:= LIMIT(minXTravel, XpPosition.x + ((SumnedVelocity.x) * MotionParameters.deltaT ) ,maxXTravel);
	XpPosition.y		:= LIMIT(minYTravel, XpPosition.y + ((SumnedVelocity.y) * MotionParameters.deltaT ) ,maxYTravel);

	
END_IF




























]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="XPlanarMover">
      <LineId Id="104" Count="0" />
      <LineId Id="101" Count="1" />
      <LineId Id="25" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="65" Count="0" />
    </LineIds>
    <LineIds Name="XPlanarMover.Cyclic">
      <LineId Id="2" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="4" Count="1" />
      <LineId Id="1" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="20" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="15" Count="0" />
    </LineIds>
    <LineIds Name="XPlanarMover.Height">
      <LineId Id="126" Count="6" />
      <LineId Id="162" Count="0" />
      <LineId Id="133" Count="6" />
      <LineId Id="163" Count="0" />
      <LineId Id="140" Count="4" />
      <LineId Id="164" Count="0" />
      <LineId Id="145" Count="4" />
      <LineId Id="165" Count="1" />
      <LineId Id="150" Count="8" />
      <LineId Id="160" Count="1" />
      <LineId Id="159" Count="0" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="XPlanarMover.Init">
      <LineId Id="108" Count="0" />
      <LineId Id="124" Count="1" />
      <LineId Id="115" Count="0" />
      <LineId Id="114" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="12" Count="24" />
      <LineId Id="43" Count="2" />
      <LineId Id="50" Count="12" />
      <LineId Id="64" Count="0" />
      <LineId Id="69" Count="24" />
      <LineId Id="135" Count="0" />
      <LineId Id="94" Count="2" />
      <LineId Id="112" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="98" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="113" Count="0" />
    </LineIds>
    <LineIds Name="XPlanarMover.Recover">
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="14" Count="6" />
      <LineId Id="55" Count="0" />
      <LineId Id="21" Count="5" />
      <LineId Id="33" Count="2" />
      <LineId Id="43" Count="1" />
      <LineId Id="62" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="53" Count="1" />
      <LineId Id="52" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="XPlanarMover.Rotation">
      <LineId Id="13" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="XPlanarMover.Tilt">
      <LineId Id="13" Count="1" />
      <LineId Id="26" Count="3" />
      <LineId Id="24" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="XPlanarMover.XYMovement">
      <LineId Id="15" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="93" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="424" Count="1" />
      <LineId Id="418" Count="1" />
      <LineId Id="397" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="192" Count="2" />
      <LineId Id="287" Count="0" />
      <LineId Id="286" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="396" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="285" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="368" Count="27" />
      <LineId Id="367" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>